# JavaScript 递归算法
> 在编程语言的中，递归（Recursion）是指函数自己调用自己的语法现象.递归算法思想与[分治算法」「深度优先遍历」等算法，以及数据结构「栈」「堆」紧密不可分。递归算法是妙不可言，我们经常惊叹于递归编写代码的简洁，但真正领悟递归的精髓并不是一件简单的事。

> 在开始之前，我们先来了解下递归算法中的几个概念。

## 递归的内涵

### 1、递归的思想

递归就是有去（递去）有回（归来），如下图所示。“有去”是指：递归问题必须可以分解为若干个规模较小，与原问题形式相同的子问题，这些子问题可以用相同的解题思路来解决，就像上面例子中的钥匙可以打开后面所有门上的锁一样；“有回”是指 : 这些问题的演化过程是一个从大到小，由近及远的过程，并且会有一个明确的终点(临界点)，一旦到达了这个临界点，就不用再往更小、更远的地方走下去。最后，从这个临界点开始，原路返回到原点，原问题解决。

### 2.数学归纳法理解递归

递归用数学模型理解，是一个归纳总结的思想。数学归纳法适合于将问题分解为多个小问题，再来解决能够解决的小问题，也和分治的思想不谋而合。绝大部分情况下分治算法都是通过递归实现，即子问题的求解通过递归方法实现。

3.递归拆分

递归可以基于「自顶向下」拆分问题，再「自底向上」逐层解决问题。这也是所熟知的「分而治之」的算法思想

## 递归函数解决步骤

递归思想分为如下三步： 
- 1.拆分问题，找到递推方程式 
- 2.解决子问题，即找到临界值，确定递归的出口 
- 3.合并问题，将子问题得到的解合并到总解上。

## 数学建模

```js
/**

* 递归算法

* @param data 问题的规模，逐步缩小问题规模

* @param 问题的解

*/

function recursion(data) {
  if (end_condition) {
    // 明确的递归终止条件

    end; // 简单情景
  } else {
    // 在将问题转换为子问题的每一步，解决该步中剩余部分的问题

    solve; // 递去，自顶向下

    recursion(data); // 递到最深处后，不断地归来

    // 归来，自底向上
  }
}
```

## 经典案例

- [509斐波那契数](assets/doc/509斐波那契数.md)
- [206反转链表](assets/doc/206反转链表.md)
- [归并排序](assets/doc/归并排序.md)


## 结果展示


## 结束

完整的代码在我的 Github 上，欢迎下载，欢迎 Star！

代码中包含三个文件：

- ga.html：展示的页面

- GA.js：遗传算法的完整代码

- common.js：通用的 JS 代码

各位大佬直接打开 ga.html 即可查看算法执行结果。也欢迎各位关注我的个人公众号，不定期分享不正经程序员的心路历程。
